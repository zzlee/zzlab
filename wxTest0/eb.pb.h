// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: eb.proto

#ifndef PROTOBUF_eb_2eproto__INCLUDED
#define PROTOBUF_eb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace eb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_eb_2eproto();
void protobuf_AssignDesc_eb_2eproto();
void protobuf_ShutdownFile_eb_2eproto();

class Size2i;
class Point2i;
class Size2f;
class Rect2i;
class Colour;
class EditorSettings;
class ControlPoint;
class LatticeSettings;
class EdgeBlendSettings;
class Workspace;

enum EditMode {
  EM_FREE = 0,
  EM_CORNER_AVERAGE = 1,
  EM_ROW_AVERAGE = 2,
  EM_COLUMN_AVERAGE = 3,
  EM_EDGE_AVERAGE = 4
};
bool EditMode_IsValid(int value);
const EditMode EditMode_MIN = EM_FREE;
const EditMode EditMode_MAX = EM_EDGE_AVERAGE;
const int EditMode_ARRAYSIZE = EditMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* EditMode_descriptor();
inline const ::std::string& EditMode_Name(EditMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    EditMode_descriptor(), value);
}
inline bool EditMode_Parse(
    const ::std::string& name, EditMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EditMode>(
    EditMode_descriptor(), name, value);
}
enum DisplayMode {
  DM_MESH_GRID = 0,
  DM_PURE_COLOUR = 1
};
bool DisplayMode_IsValid(int value);
const DisplayMode DisplayMode_MIN = DM_MESH_GRID;
const DisplayMode DisplayMode_MAX = DM_PURE_COLOUR;
const int DisplayMode_ARRAYSIZE = DisplayMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* DisplayMode_descriptor();
inline const ::std::string& DisplayMode_Name(DisplayMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    DisplayMode_descriptor(), value);
}
inline bool DisplayMode_Parse(
    const ::std::string& name, DisplayMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplayMode>(
    DisplayMode_descriptor(), name, value);
}
enum SelectMode {
  SM_SINGLE = 0,
  SM_ROW = 1,
  SM_COLUMN = 2,
  SM_CROSS = 3
};
bool SelectMode_IsValid(int value);
const SelectMode SelectMode_MIN = SM_SINGLE;
const SelectMode SelectMode_MAX = SM_CROSS;
const int SelectMode_ARRAYSIZE = SelectMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SelectMode_descriptor();
inline const ::std::string& SelectMode_Name(SelectMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SelectMode_descriptor(), value);
}
inline bool SelectMode_Parse(
    const ::std::string& name, SelectMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SelectMode>(
    SelectMode_descriptor(), name, value);
}
enum ControlPointType {
  CP_FREE = 0,
  CP_CEASE = 1
};
bool ControlPointType_IsValid(int value);
const ControlPointType ControlPointType_MIN = CP_FREE;
const ControlPointType ControlPointType_MAX = CP_CEASE;
const int ControlPointType_ARRAYSIZE = ControlPointType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControlPointType_descriptor();
inline const ::std::string& ControlPointType_Name(ControlPointType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlPointType_descriptor(), value);
}
inline bool ControlPointType_Parse(
    const ::std::string& name, ControlPointType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlPointType>(
    ControlPointType_descriptor(), name, value);
}
// ===================================================================

class Size2i : public ::google::protobuf::Message {
 public:
  Size2i();
  virtual ~Size2i();

  Size2i(const Size2i& from);

  inline Size2i& operator=(const Size2i& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Size2i& default_instance();

  void Swap(Size2i* other);

  // implements Message ----------------------------------------------

  Size2i* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Size2i& from);
  void MergeFrom(const Size2i& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eb.Size2i)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static Size2i* default_instance_;
};
// -------------------------------------------------------------------

class Point2i : public ::google::protobuf::Message {
 public:
  Point2i();
  virtual ~Point2i();

  Point2i(const Point2i& from);

  inline Point2i& operator=(const Point2i& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2i& default_instance();

  void Swap(Point2i* other);

  // implements Message ----------------------------------------------

  Point2i* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point2i& from);
  void MergeFrom(const Point2i& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eb.Point2i)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static Point2i* default_instance_;
};
// -------------------------------------------------------------------

class Size2f : public ::google::protobuf::Message {
 public:
  Size2f();
  virtual ~Size2f();

  Size2f(const Size2f& from);

  inline Size2f& operator=(const Size2f& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Size2f& default_instance();

  void Swap(Size2f* other);

  // implements Message ----------------------------------------------

  Size2f* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Size2f& from);
  void MergeFrom(const Size2f& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline float width() const;
  inline void set_width(float value);

  // required float height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline float height() const;
  inline void set_height(float value);

  // @@protoc_insertion_point(class_scope:eb.Size2f)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float width_;
  float height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static Size2f* default_instance_;
};
// -------------------------------------------------------------------

class Rect2i : public ::google::protobuf::Message {
 public:
  Rect2i();
  virtual ~Rect2i();

  Rect2i(const Rect2i& from);

  inline Rect2i& operator=(const Rect2i& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rect2i& default_instance();

  void Swap(Rect2i* other);

  // implements Message ----------------------------------------------

  Rect2i* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rect2i& from);
  void MergeFrom(const Rect2i& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required int32 top = 2;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 2;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required int32 right = 3;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 3;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required int32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eb.Rect2i)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 bottom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static Rect2i* default_instance_;
};
// -------------------------------------------------------------------

class Colour : public ::google::protobuf::Message {
 public:
  Colour();
  virtual ~Colour();

  Colour(const Colour& from);

  inline Colour& operator=(const Colour& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Colour& default_instance();

  void Swap(Colour* other);

  // implements Message ----------------------------------------------

  Colour* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Colour& from);
  void MergeFrom(const Colour& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float r = 1;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 1;
  inline float r() const;
  inline void set_r(float value);

  // required float g = 2;
  inline bool has_g() const;
  inline void clear_g();
  static const int kGFieldNumber = 2;
  inline float g() const;
  inline void set_g(float value);

  // required float b = 3;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 3;
  inline float b() const;
  inline void set_b(float value);

  // @@protoc_insertion_point(class_scope:eb.Colour)
 private:
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_g();
  inline void clear_has_g();
  inline void set_has_b();
  inline void clear_has_b();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float r_;
  float g_;
  float b_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static Colour* default_instance_;
};
// -------------------------------------------------------------------

class EditorSettings : public ::google::protobuf::Message {
 public:
  EditorSettings();
  virtual ~EditorSettings();

  EditorSettings(const EditorSettings& from);

  inline EditorSettings& operator=(const EditorSettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EditorSettings& default_instance();

  void Swap(EditorSettings* other);

  // implements Message ----------------------------------------------

  EditorSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EditorSettings& from);
  void MergeFrom(const EditorSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .eb.DisplayMode display_mode = 12;
  inline bool has_display_mode() const;
  inline void clear_display_mode();
  static const int kDisplayModeFieldNumber = 12;
  inline ::eb::DisplayMode display_mode() const;
  inline void set_display_mode(::eb::DisplayMode value);

  // required .eb.EditMode edit_mode = 1;
  inline bool has_edit_mode() const;
  inline void clear_edit_mode();
  static const int kEditModeFieldNumber = 1;
  inline ::eb::EditMode edit_mode() const;
  inline void set_edit_mode(::eb::EditMode value);

  // required .eb.Colour line_colour = 4;
  inline bool has_line_colour() const;
  inline void clear_line_colour();
  static const int kLineColourFieldNumber = 4;
  inline const ::eb::Colour& line_colour() const;
  inline ::eb::Colour* mutable_line_colour();
  inline ::eb::Colour* release_line_colour();
  inline void set_allocated_line_colour(::eb::Colour* line_colour);

  // required .eb.Colour background_colour = 5;
  inline bool has_background_colour() const;
  inline void clear_background_colour();
  static const int kBackgroundColourFieldNumber = 5;
  inline const ::eb::Colour& background_colour() const;
  inline ::eb::Colour* mutable_background_colour();
  inline ::eb::Colour* release_background_colour();
  inline void set_allocated_background_colour(::eb::Colour* background_colour);

  // required float adjust_speed = 7;
  inline bool has_adjust_speed() const;
  inline void clear_adjust_speed();
  static const int kAdjustSpeedFieldNumber = 7;
  inline float adjust_speed() const;
  inline void set_adjust_speed(float value);

  // required bool show_control_point = 8;
  inline bool has_show_control_point() const;
  inline void clear_show_control_point();
  static const int kShowControlPointFieldNumber = 8;
  inline bool show_control_point() const;
  inline void set_show_control_point(bool value);

  // required .eb.Size2i grid_size = 9;
  inline bool has_grid_size() const;
  inline void clear_grid_size();
  static const int kGridSizeFieldNumber = 9;
  inline const ::eb::Size2i& grid_size() const;
  inline ::eb::Size2i* mutable_grid_size();
  inline ::eb::Size2i* release_grid_size();
  inline void set_allocated_grid_size(::eb::Size2i* grid_size);

  // required .eb.SelectMode select_mode = 10;
  inline bool has_select_mode() const;
  inline void clear_select_mode();
  static const int kSelectModeFieldNumber = 10;
  inline ::eb::SelectMode select_mode() const;
  inline void set_select_mode(::eb::SelectMode value);

  // required .eb.Point2i selected = 11;
  inline bool has_selected() const;
  inline void clear_selected();
  static const int kSelectedFieldNumber = 11;
  inline const ::eb::Point2i& selected() const;
  inline ::eb::Point2i* mutable_selected();
  inline ::eb::Point2i* release_selected();
  inline void set_allocated_selected(::eb::Point2i* selected);

  // @@protoc_insertion_point(class_scope:eb.EditorSettings)
 private:
  inline void set_has_display_mode();
  inline void clear_has_display_mode();
  inline void set_has_edit_mode();
  inline void clear_has_edit_mode();
  inline void set_has_line_colour();
  inline void clear_has_line_colour();
  inline void set_has_background_colour();
  inline void clear_has_background_colour();
  inline void set_has_adjust_speed();
  inline void clear_has_adjust_speed();
  inline void set_has_show_control_point();
  inline void clear_has_show_control_point();
  inline void set_has_grid_size();
  inline void clear_has_grid_size();
  inline void set_has_select_mode();
  inline void clear_has_select_mode();
  inline void set_has_selected();
  inline void clear_has_selected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int display_mode_;
  int edit_mode_;
  ::eb::Colour* line_colour_;
  ::eb::Colour* background_colour_;
  float adjust_speed_;
  bool show_control_point_;
  ::eb::Size2i* grid_size_;
  ::eb::Point2i* selected_;
  int select_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static EditorSettings* default_instance_;
};
// -------------------------------------------------------------------

class ControlPoint : public ::google::protobuf::Message {
 public:
  ControlPoint();
  virtual ~ControlPoint();

  ControlPoint(const ControlPoint& from);

  inline ControlPoint& operator=(const ControlPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlPoint& default_instance();

  void Swap(ControlPoint* other);

  // implements Message ----------------------------------------------

  ControlPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlPoint& from);
  void MergeFrom(const ControlPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .eb.ControlPointType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::eb::ControlPointType type() const;
  inline void set_type(::eb::ControlPointType value);

  // required float x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:eb.ControlPoint)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static ControlPoint* default_instance_;
};
// -------------------------------------------------------------------

class LatticeSettings : public ::google::protobuf::Message {
 public:
  LatticeSettings();
  virtual ~LatticeSettings();

  LatticeSettings(const LatticeSettings& from);

  inline LatticeSettings& operator=(const LatticeSettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LatticeSettings& default_instance();

  void Swap(LatticeSettings* other);

  // implements Message ----------------------------------------------

  LatticeSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LatticeSettings& from);
  void MergeFrom(const LatticeSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .eb.Size2i size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline const ::eb::Size2i& size() const;
  inline ::eb::Size2i* mutable_size();
  inline ::eb::Size2i* release_size();
  inline void set_allocated_size(::eb::Size2i* size);

  // required uint32 subdiv_level = 2;
  inline bool has_subdiv_level() const;
  inline void clear_subdiv_level();
  static const int kSubdivLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 subdiv_level() const;
  inline void set_subdiv_level(::google::protobuf::uint32 value);

  // repeated .eb.ControlPoint control_points = 3;
  inline int control_points_size() const;
  inline void clear_control_points();
  static const int kControlPointsFieldNumber = 3;
  inline const ::eb::ControlPoint& control_points(int index) const;
  inline ::eb::ControlPoint* mutable_control_points(int index);
  inline ::eb::ControlPoint* add_control_points();
  inline const ::google::protobuf::RepeatedPtrField< ::eb::ControlPoint >&
      control_points() const;
  inline ::google::protobuf::RepeatedPtrField< ::eb::ControlPoint >*
      mutable_control_points();

  // @@protoc_insertion_point(class_scope:eb.LatticeSettings)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_subdiv_level();
  inline void clear_has_subdiv_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::eb::Size2i* size_;
  ::google::protobuf::RepeatedPtrField< ::eb::ControlPoint > control_points_;
  ::google::protobuf::uint32 subdiv_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static LatticeSettings* default_instance_;
};
// -------------------------------------------------------------------

class EdgeBlendSettings : public ::google::protobuf::Message {
 public:
  EdgeBlendSettings();
  virtual ~EdgeBlendSettings();

  EdgeBlendSettings(const EdgeBlendSettings& from);

  inline EdgeBlendSettings& operator=(const EdgeBlendSettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeBlendSettings& default_instance();

  void Swap(EdgeBlendSettings* other);

  // implements Message ----------------------------------------------

  EdgeBlendSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EdgeBlendSettings& from);
  void MergeFrom(const EdgeBlendSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // required uint32 width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // required float blending = 3;
  inline bool has_blending() const;
  inline void clear_blending();
  static const int kBlendingFieldNumber = 3;
  inline float blending() const;
  inline void set_blending(float value);

  // required float gamma = 4;
  inline bool has_gamma() const;
  inline void clear_gamma();
  static const int kGammaFieldNumber = 4;
  inline float gamma() const;
  inline void set_gamma(float value);

  // required float center = 5;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 5;
  inline float center() const;
  inline void set_center(float value);

  // @@protoc_insertion_point(class_scope:eb.EdgeBlendSettings)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_blending();
  inline void clear_has_blending();
  inline void set_has_gamma();
  inline void clear_has_gamma();
  inline void set_has_center();
  inline void clear_has_center();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  ::google::protobuf::uint32 width_;
  float blending_;
  float gamma_;
  float center_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static EdgeBlendSettings* default_instance_;
};
// -------------------------------------------------------------------

class Workspace : public ::google::protobuf::Message {
 public:
  Workspace();
  virtual ~Workspace();

  Workspace(const Workspace& from);

  inline Workspace& operator=(const Workspace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Workspace& default_instance();

  void Swap(Workspace* other);

  // implements Message ----------------------------------------------

  Workspace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Workspace& from);
  void MergeFrom(const Workspace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .eb.EditorSettings editor_settings = 1;
  inline bool has_editor_settings() const;
  inline void clear_editor_settings();
  static const int kEditorSettingsFieldNumber = 1;
  inline const ::eb::EditorSettings& editor_settings() const;
  inline ::eb::EditorSettings* mutable_editor_settings();
  inline ::eb::EditorSettings* release_editor_settings();
  inline void set_allocated_editor_settings(::eb::EditorSettings* editor_settings);

  // required .eb.LatticeSettings lattice_settings = 2;
  inline bool has_lattice_settings() const;
  inline void clear_lattice_settings();
  static const int kLatticeSettingsFieldNumber = 2;
  inline const ::eb::LatticeSettings& lattice_settings() const;
  inline ::eb::LatticeSettings* mutable_lattice_settings();
  inline ::eb::LatticeSettings* release_lattice_settings();
  inline void set_allocated_lattice_settings(::eb::LatticeSettings* lattice_settings);

  // required .eb.EdgeBlendSettings left_edge_settings = 3;
  inline bool has_left_edge_settings() const;
  inline void clear_left_edge_settings();
  static const int kLeftEdgeSettingsFieldNumber = 3;
  inline const ::eb::EdgeBlendSettings& left_edge_settings() const;
  inline ::eb::EdgeBlendSettings* mutable_left_edge_settings();
  inline ::eb::EdgeBlendSettings* release_left_edge_settings();
  inline void set_allocated_left_edge_settings(::eb::EdgeBlendSettings* left_edge_settings);

  // required .eb.EdgeBlendSettings top_edge_settings = 4;
  inline bool has_top_edge_settings() const;
  inline void clear_top_edge_settings();
  static const int kTopEdgeSettingsFieldNumber = 4;
  inline const ::eb::EdgeBlendSettings& top_edge_settings() const;
  inline ::eb::EdgeBlendSettings* mutable_top_edge_settings();
  inline ::eb::EdgeBlendSettings* release_top_edge_settings();
  inline void set_allocated_top_edge_settings(::eb::EdgeBlendSettings* top_edge_settings);

  // required .eb.EdgeBlendSettings right_edge_settings = 5;
  inline bool has_right_edge_settings() const;
  inline void clear_right_edge_settings();
  static const int kRightEdgeSettingsFieldNumber = 5;
  inline const ::eb::EdgeBlendSettings& right_edge_settings() const;
  inline ::eb::EdgeBlendSettings* mutable_right_edge_settings();
  inline ::eb::EdgeBlendSettings* release_right_edge_settings();
  inline void set_allocated_right_edge_settings(::eb::EdgeBlendSettings* right_edge_settings);

  // required .eb.EdgeBlendSettings bottom_edge_settings = 6;
  inline bool has_bottom_edge_settings() const;
  inline void clear_bottom_edge_settings();
  static const int kBottomEdgeSettingsFieldNumber = 6;
  inline const ::eb::EdgeBlendSettings& bottom_edge_settings() const;
  inline ::eb::EdgeBlendSettings* mutable_bottom_edge_settings();
  inline ::eb::EdgeBlendSettings* release_bottom_edge_settings();
  inline void set_allocated_bottom_edge_settings(::eb::EdgeBlendSettings* bottom_edge_settings);

  // @@protoc_insertion_point(class_scope:eb.Workspace)
 private:
  inline void set_has_editor_settings();
  inline void clear_has_editor_settings();
  inline void set_has_lattice_settings();
  inline void clear_has_lattice_settings();
  inline void set_has_left_edge_settings();
  inline void clear_has_left_edge_settings();
  inline void set_has_top_edge_settings();
  inline void clear_has_top_edge_settings();
  inline void set_has_right_edge_settings();
  inline void clear_has_right_edge_settings();
  inline void set_has_bottom_edge_settings();
  inline void clear_has_bottom_edge_settings();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::eb::EditorSettings* editor_settings_;
  ::eb::LatticeSettings* lattice_settings_;
  ::eb::EdgeBlendSettings* left_edge_settings_;
  ::eb::EdgeBlendSettings* top_edge_settings_;
  ::eb::EdgeBlendSettings* right_edge_settings_;
  ::eb::EdgeBlendSettings* bottom_edge_settings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_eb_2eproto();
  friend void protobuf_AssignDesc_eb_2eproto();
  friend void protobuf_ShutdownFile_eb_2eproto();

  void InitAsDefaultInstance();
  static Workspace* default_instance_;
};
// ===================================================================


// ===================================================================

// Size2i

// required uint32 width = 1;
inline bool Size2i::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Size2i::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Size2i::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Size2i::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Size2i::width() const {
  return width_;
}
inline void Size2i::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// required uint32 height = 2;
inline bool Size2i::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Size2i::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Size2i::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Size2i::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Size2i::height() const {
  return height_;
}
inline void Size2i::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// Point2i

// required int32 x = 1;
inline bool Point2i::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2i::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2i::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2i::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Point2i::x() const {
  return x_;
}
inline void Point2i::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Point2i::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2i::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2i::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2i::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Point2i::y() const {
  return y_;
}
inline void Point2i::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Size2f

// required float width = 1;
inline bool Size2f::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Size2f::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Size2f::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Size2f::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float Size2f::width() const {
  return width_;
}
inline void Size2f::set_width(float value) {
  set_has_width();
  width_ = value;
}

// required float height = 2;
inline bool Size2f::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Size2f::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Size2f::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Size2f::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float Size2f::height() const {
  return height_;
}
inline void Size2f::set_height(float value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// Rect2i

// required int32 left = 1;
inline bool Rect2i::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect2i::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rect2i::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rect2i::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 Rect2i::left() const {
  return left_;
}
inline void Rect2i::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required int32 top = 2;
inline bool Rect2i::has_top() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect2i::set_has_top() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rect2i::clear_has_top() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rect2i::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 Rect2i::top() const {
  return top_;
}
inline void Rect2i::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required int32 right = 3;
inline bool Rect2i::has_right() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect2i::set_has_right() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rect2i::clear_has_right() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rect2i::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 Rect2i::right() const {
  return right_;
}
inline void Rect2i::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required int32 bottom = 4;
inline bool Rect2i::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect2i::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rect2i::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rect2i::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 Rect2i::bottom() const {
  return bottom_;
}
inline void Rect2i::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// -------------------------------------------------------------------

// Colour

// required float r = 1;
inline bool Colour::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Colour::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Colour::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Colour::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline float Colour::r() const {
  return r_;
}
inline void Colour::set_r(float value) {
  set_has_r();
  r_ = value;
}

// required float g = 2;
inline bool Colour::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Colour::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Colour::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Colour::clear_g() {
  g_ = 0;
  clear_has_g();
}
inline float Colour::g() const {
  return g_;
}
inline void Colour::set_g(float value) {
  set_has_g();
  g_ = value;
}

// required float b = 3;
inline bool Colour::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Colour::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Colour::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Colour::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline float Colour::b() const {
  return b_;
}
inline void Colour::set_b(float value) {
  set_has_b();
  b_ = value;
}

// -------------------------------------------------------------------

// EditorSettings

// required .eb.DisplayMode display_mode = 12;
inline bool EditorSettings::has_display_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EditorSettings::set_has_display_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EditorSettings::clear_has_display_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EditorSettings::clear_display_mode() {
  display_mode_ = 0;
  clear_has_display_mode();
}
inline ::eb::DisplayMode EditorSettings::display_mode() const {
  return static_cast< ::eb::DisplayMode >(display_mode_);
}
inline void EditorSettings::set_display_mode(::eb::DisplayMode value) {
  assert(::eb::DisplayMode_IsValid(value));
  set_has_display_mode();
  display_mode_ = value;
}

// required .eb.EditMode edit_mode = 1;
inline bool EditorSettings::has_edit_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EditorSettings::set_has_edit_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EditorSettings::clear_has_edit_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EditorSettings::clear_edit_mode() {
  edit_mode_ = 0;
  clear_has_edit_mode();
}
inline ::eb::EditMode EditorSettings::edit_mode() const {
  return static_cast< ::eb::EditMode >(edit_mode_);
}
inline void EditorSettings::set_edit_mode(::eb::EditMode value) {
  assert(::eb::EditMode_IsValid(value));
  set_has_edit_mode();
  edit_mode_ = value;
}

// required .eb.Colour line_colour = 4;
inline bool EditorSettings::has_line_colour() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EditorSettings::set_has_line_colour() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EditorSettings::clear_has_line_colour() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EditorSettings::clear_line_colour() {
  if (line_colour_ != NULL) line_colour_->::eb::Colour::Clear();
  clear_has_line_colour();
}
inline const ::eb::Colour& EditorSettings::line_colour() const {
  return line_colour_ != NULL ? *line_colour_ : *default_instance_->line_colour_;
}
inline ::eb::Colour* EditorSettings::mutable_line_colour() {
  set_has_line_colour();
  if (line_colour_ == NULL) line_colour_ = new ::eb::Colour;
  return line_colour_;
}
inline ::eb::Colour* EditorSettings::release_line_colour() {
  clear_has_line_colour();
  ::eb::Colour* temp = line_colour_;
  line_colour_ = NULL;
  return temp;
}
inline void EditorSettings::set_allocated_line_colour(::eb::Colour* line_colour) {
  delete line_colour_;
  line_colour_ = line_colour;
  if (line_colour) {
    set_has_line_colour();
  } else {
    clear_has_line_colour();
  }
}

// required .eb.Colour background_colour = 5;
inline bool EditorSettings::has_background_colour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EditorSettings::set_has_background_colour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EditorSettings::clear_has_background_colour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EditorSettings::clear_background_colour() {
  if (background_colour_ != NULL) background_colour_->::eb::Colour::Clear();
  clear_has_background_colour();
}
inline const ::eb::Colour& EditorSettings::background_colour() const {
  return background_colour_ != NULL ? *background_colour_ : *default_instance_->background_colour_;
}
inline ::eb::Colour* EditorSettings::mutable_background_colour() {
  set_has_background_colour();
  if (background_colour_ == NULL) background_colour_ = new ::eb::Colour;
  return background_colour_;
}
inline ::eb::Colour* EditorSettings::release_background_colour() {
  clear_has_background_colour();
  ::eb::Colour* temp = background_colour_;
  background_colour_ = NULL;
  return temp;
}
inline void EditorSettings::set_allocated_background_colour(::eb::Colour* background_colour) {
  delete background_colour_;
  background_colour_ = background_colour;
  if (background_colour) {
    set_has_background_colour();
  } else {
    clear_has_background_colour();
  }
}

// required float adjust_speed = 7;
inline bool EditorSettings::has_adjust_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EditorSettings::set_has_adjust_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EditorSettings::clear_has_adjust_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EditorSettings::clear_adjust_speed() {
  adjust_speed_ = 0;
  clear_has_adjust_speed();
}
inline float EditorSettings::adjust_speed() const {
  return adjust_speed_;
}
inline void EditorSettings::set_adjust_speed(float value) {
  set_has_adjust_speed();
  adjust_speed_ = value;
}

// required bool show_control_point = 8;
inline bool EditorSettings::has_show_control_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EditorSettings::set_has_show_control_point() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EditorSettings::clear_has_show_control_point() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EditorSettings::clear_show_control_point() {
  show_control_point_ = false;
  clear_has_show_control_point();
}
inline bool EditorSettings::show_control_point() const {
  return show_control_point_;
}
inline void EditorSettings::set_show_control_point(bool value) {
  set_has_show_control_point();
  show_control_point_ = value;
}

// required .eb.Size2i grid_size = 9;
inline bool EditorSettings::has_grid_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EditorSettings::set_has_grid_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EditorSettings::clear_has_grid_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EditorSettings::clear_grid_size() {
  if (grid_size_ != NULL) grid_size_->::eb::Size2i::Clear();
  clear_has_grid_size();
}
inline const ::eb::Size2i& EditorSettings::grid_size() const {
  return grid_size_ != NULL ? *grid_size_ : *default_instance_->grid_size_;
}
inline ::eb::Size2i* EditorSettings::mutable_grid_size() {
  set_has_grid_size();
  if (grid_size_ == NULL) grid_size_ = new ::eb::Size2i;
  return grid_size_;
}
inline ::eb::Size2i* EditorSettings::release_grid_size() {
  clear_has_grid_size();
  ::eb::Size2i* temp = grid_size_;
  grid_size_ = NULL;
  return temp;
}
inline void EditorSettings::set_allocated_grid_size(::eb::Size2i* grid_size) {
  delete grid_size_;
  grid_size_ = grid_size;
  if (grid_size) {
    set_has_grid_size();
  } else {
    clear_has_grid_size();
  }
}

// required .eb.SelectMode select_mode = 10;
inline bool EditorSettings::has_select_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EditorSettings::set_has_select_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EditorSettings::clear_has_select_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EditorSettings::clear_select_mode() {
  select_mode_ = 0;
  clear_has_select_mode();
}
inline ::eb::SelectMode EditorSettings::select_mode() const {
  return static_cast< ::eb::SelectMode >(select_mode_);
}
inline void EditorSettings::set_select_mode(::eb::SelectMode value) {
  assert(::eb::SelectMode_IsValid(value));
  set_has_select_mode();
  select_mode_ = value;
}

// required .eb.Point2i selected = 11;
inline bool EditorSettings::has_selected() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EditorSettings::set_has_selected() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EditorSettings::clear_has_selected() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EditorSettings::clear_selected() {
  if (selected_ != NULL) selected_->::eb::Point2i::Clear();
  clear_has_selected();
}
inline const ::eb::Point2i& EditorSettings::selected() const {
  return selected_ != NULL ? *selected_ : *default_instance_->selected_;
}
inline ::eb::Point2i* EditorSettings::mutable_selected() {
  set_has_selected();
  if (selected_ == NULL) selected_ = new ::eb::Point2i;
  return selected_;
}
inline ::eb::Point2i* EditorSettings::release_selected() {
  clear_has_selected();
  ::eb::Point2i* temp = selected_;
  selected_ = NULL;
  return temp;
}
inline void EditorSettings::set_allocated_selected(::eb::Point2i* selected) {
  delete selected_;
  selected_ = selected;
  if (selected) {
    set_has_selected();
  } else {
    clear_has_selected();
  }
}

// -------------------------------------------------------------------

// ControlPoint

// required .eb.ControlPointType type = 1;
inline bool ControlPoint::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlPoint::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlPoint::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlPoint::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::eb::ControlPointType ControlPoint::type() const {
  return static_cast< ::eb::ControlPointType >(type_);
}
inline void ControlPoint::set_type(::eb::ControlPointType value) {
  assert(::eb::ControlPointType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required float x = 2;
inline bool ControlPoint::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlPoint::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float ControlPoint::x() const {
  return x_;
}
inline void ControlPoint::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 3;
inline bool ControlPoint::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlPoint::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float ControlPoint::y() const {
  return y_;
}
inline void ControlPoint::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// LatticeSettings

// required .eb.Size2i size = 1;
inline bool LatticeSettings::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatticeSettings::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatticeSettings::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatticeSettings::clear_size() {
  if (size_ != NULL) size_->::eb::Size2i::Clear();
  clear_has_size();
}
inline const ::eb::Size2i& LatticeSettings::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::eb::Size2i* LatticeSettings::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::eb::Size2i;
  return size_;
}
inline ::eb::Size2i* LatticeSettings::release_size() {
  clear_has_size();
  ::eb::Size2i* temp = size_;
  size_ = NULL;
  return temp;
}
inline void LatticeSettings::set_allocated_size(::eb::Size2i* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// required uint32 subdiv_level = 2;
inline bool LatticeSettings::has_subdiv_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatticeSettings::set_has_subdiv_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatticeSettings::clear_has_subdiv_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatticeSettings::clear_subdiv_level() {
  subdiv_level_ = 0u;
  clear_has_subdiv_level();
}
inline ::google::protobuf::uint32 LatticeSettings::subdiv_level() const {
  return subdiv_level_;
}
inline void LatticeSettings::set_subdiv_level(::google::protobuf::uint32 value) {
  set_has_subdiv_level();
  subdiv_level_ = value;
}

// repeated .eb.ControlPoint control_points = 3;
inline int LatticeSettings::control_points_size() const {
  return control_points_.size();
}
inline void LatticeSettings::clear_control_points() {
  control_points_.Clear();
}
inline const ::eb::ControlPoint& LatticeSettings::control_points(int index) const {
  return control_points_.Get(index);
}
inline ::eb::ControlPoint* LatticeSettings::mutable_control_points(int index) {
  return control_points_.Mutable(index);
}
inline ::eb::ControlPoint* LatticeSettings::add_control_points() {
  return control_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eb::ControlPoint >&
LatticeSettings::control_points() const {
  return control_points_;
}
inline ::google::protobuf::RepeatedPtrField< ::eb::ControlPoint >*
LatticeSettings::mutable_control_points() {
  return &control_points_;
}

// -------------------------------------------------------------------

// EdgeBlendSettings

// required bool enable = 1;
inline bool EdgeBlendSettings::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgeBlendSettings::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgeBlendSettings::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgeBlendSettings::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool EdgeBlendSettings::enable() const {
  return enable_;
}
inline void EdgeBlendSettings::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// required uint32 width = 2;
inline bool EdgeBlendSettings::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EdgeBlendSettings::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EdgeBlendSettings::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EdgeBlendSettings::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 EdgeBlendSettings::width() const {
  return width_;
}
inline void EdgeBlendSettings::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// required float blending = 3;
inline bool EdgeBlendSettings::has_blending() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EdgeBlendSettings::set_has_blending() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EdgeBlendSettings::clear_has_blending() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EdgeBlendSettings::clear_blending() {
  blending_ = 0;
  clear_has_blending();
}
inline float EdgeBlendSettings::blending() const {
  return blending_;
}
inline void EdgeBlendSettings::set_blending(float value) {
  set_has_blending();
  blending_ = value;
}

// required float gamma = 4;
inline bool EdgeBlendSettings::has_gamma() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EdgeBlendSettings::set_has_gamma() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EdgeBlendSettings::clear_has_gamma() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EdgeBlendSettings::clear_gamma() {
  gamma_ = 0;
  clear_has_gamma();
}
inline float EdgeBlendSettings::gamma() const {
  return gamma_;
}
inline void EdgeBlendSettings::set_gamma(float value) {
  set_has_gamma();
  gamma_ = value;
}

// required float center = 5;
inline bool EdgeBlendSettings::has_center() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EdgeBlendSettings::set_has_center() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EdgeBlendSettings::clear_has_center() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EdgeBlendSettings::clear_center() {
  center_ = 0;
  clear_has_center();
}
inline float EdgeBlendSettings::center() const {
  return center_;
}
inline void EdgeBlendSettings::set_center(float value) {
  set_has_center();
  center_ = value;
}

// -------------------------------------------------------------------

// Workspace

// required .eb.EditorSettings editor_settings = 1;
inline bool Workspace::has_editor_settings() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Workspace::set_has_editor_settings() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Workspace::clear_has_editor_settings() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Workspace::clear_editor_settings() {
  if (editor_settings_ != NULL) editor_settings_->::eb::EditorSettings::Clear();
  clear_has_editor_settings();
}
inline const ::eb::EditorSettings& Workspace::editor_settings() const {
  return editor_settings_ != NULL ? *editor_settings_ : *default_instance_->editor_settings_;
}
inline ::eb::EditorSettings* Workspace::mutable_editor_settings() {
  set_has_editor_settings();
  if (editor_settings_ == NULL) editor_settings_ = new ::eb::EditorSettings;
  return editor_settings_;
}
inline ::eb::EditorSettings* Workspace::release_editor_settings() {
  clear_has_editor_settings();
  ::eb::EditorSettings* temp = editor_settings_;
  editor_settings_ = NULL;
  return temp;
}
inline void Workspace::set_allocated_editor_settings(::eb::EditorSettings* editor_settings) {
  delete editor_settings_;
  editor_settings_ = editor_settings;
  if (editor_settings) {
    set_has_editor_settings();
  } else {
    clear_has_editor_settings();
  }
}

// required .eb.LatticeSettings lattice_settings = 2;
inline bool Workspace::has_lattice_settings() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Workspace::set_has_lattice_settings() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Workspace::clear_has_lattice_settings() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Workspace::clear_lattice_settings() {
  if (lattice_settings_ != NULL) lattice_settings_->::eb::LatticeSettings::Clear();
  clear_has_lattice_settings();
}
inline const ::eb::LatticeSettings& Workspace::lattice_settings() const {
  return lattice_settings_ != NULL ? *lattice_settings_ : *default_instance_->lattice_settings_;
}
inline ::eb::LatticeSettings* Workspace::mutable_lattice_settings() {
  set_has_lattice_settings();
  if (lattice_settings_ == NULL) lattice_settings_ = new ::eb::LatticeSettings;
  return lattice_settings_;
}
inline ::eb::LatticeSettings* Workspace::release_lattice_settings() {
  clear_has_lattice_settings();
  ::eb::LatticeSettings* temp = lattice_settings_;
  lattice_settings_ = NULL;
  return temp;
}
inline void Workspace::set_allocated_lattice_settings(::eb::LatticeSettings* lattice_settings) {
  delete lattice_settings_;
  lattice_settings_ = lattice_settings;
  if (lattice_settings) {
    set_has_lattice_settings();
  } else {
    clear_has_lattice_settings();
  }
}

// required .eb.EdgeBlendSettings left_edge_settings = 3;
inline bool Workspace::has_left_edge_settings() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Workspace::set_has_left_edge_settings() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Workspace::clear_has_left_edge_settings() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Workspace::clear_left_edge_settings() {
  if (left_edge_settings_ != NULL) left_edge_settings_->::eb::EdgeBlendSettings::Clear();
  clear_has_left_edge_settings();
}
inline const ::eb::EdgeBlendSettings& Workspace::left_edge_settings() const {
  return left_edge_settings_ != NULL ? *left_edge_settings_ : *default_instance_->left_edge_settings_;
}
inline ::eb::EdgeBlendSettings* Workspace::mutable_left_edge_settings() {
  set_has_left_edge_settings();
  if (left_edge_settings_ == NULL) left_edge_settings_ = new ::eb::EdgeBlendSettings;
  return left_edge_settings_;
}
inline ::eb::EdgeBlendSettings* Workspace::release_left_edge_settings() {
  clear_has_left_edge_settings();
  ::eb::EdgeBlendSettings* temp = left_edge_settings_;
  left_edge_settings_ = NULL;
  return temp;
}
inline void Workspace::set_allocated_left_edge_settings(::eb::EdgeBlendSettings* left_edge_settings) {
  delete left_edge_settings_;
  left_edge_settings_ = left_edge_settings;
  if (left_edge_settings) {
    set_has_left_edge_settings();
  } else {
    clear_has_left_edge_settings();
  }
}

// required .eb.EdgeBlendSettings top_edge_settings = 4;
inline bool Workspace::has_top_edge_settings() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Workspace::set_has_top_edge_settings() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Workspace::clear_has_top_edge_settings() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Workspace::clear_top_edge_settings() {
  if (top_edge_settings_ != NULL) top_edge_settings_->::eb::EdgeBlendSettings::Clear();
  clear_has_top_edge_settings();
}
inline const ::eb::EdgeBlendSettings& Workspace::top_edge_settings() const {
  return top_edge_settings_ != NULL ? *top_edge_settings_ : *default_instance_->top_edge_settings_;
}
inline ::eb::EdgeBlendSettings* Workspace::mutable_top_edge_settings() {
  set_has_top_edge_settings();
  if (top_edge_settings_ == NULL) top_edge_settings_ = new ::eb::EdgeBlendSettings;
  return top_edge_settings_;
}
inline ::eb::EdgeBlendSettings* Workspace::release_top_edge_settings() {
  clear_has_top_edge_settings();
  ::eb::EdgeBlendSettings* temp = top_edge_settings_;
  top_edge_settings_ = NULL;
  return temp;
}
inline void Workspace::set_allocated_top_edge_settings(::eb::EdgeBlendSettings* top_edge_settings) {
  delete top_edge_settings_;
  top_edge_settings_ = top_edge_settings;
  if (top_edge_settings) {
    set_has_top_edge_settings();
  } else {
    clear_has_top_edge_settings();
  }
}

// required .eb.EdgeBlendSettings right_edge_settings = 5;
inline bool Workspace::has_right_edge_settings() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Workspace::set_has_right_edge_settings() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Workspace::clear_has_right_edge_settings() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Workspace::clear_right_edge_settings() {
  if (right_edge_settings_ != NULL) right_edge_settings_->::eb::EdgeBlendSettings::Clear();
  clear_has_right_edge_settings();
}
inline const ::eb::EdgeBlendSettings& Workspace::right_edge_settings() const {
  return right_edge_settings_ != NULL ? *right_edge_settings_ : *default_instance_->right_edge_settings_;
}
inline ::eb::EdgeBlendSettings* Workspace::mutable_right_edge_settings() {
  set_has_right_edge_settings();
  if (right_edge_settings_ == NULL) right_edge_settings_ = new ::eb::EdgeBlendSettings;
  return right_edge_settings_;
}
inline ::eb::EdgeBlendSettings* Workspace::release_right_edge_settings() {
  clear_has_right_edge_settings();
  ::eb::EdgeBlendSettings* temp = right_edge_settings_;
  right_edge_settings_ = NULL;
  return temp;
}
inline void Workspace::set_allocated_right_edge_settings(::eb::EdgeBlendSettings* right_edge_settings) {
  delete right_edge_settings_;
  right_edge_settings_ = right_edge_settings;
  if (right_edge_settings) {
    set_has_right_edge_settings();
  } else {
    clear_has_right_edge_settings();
  }
}

// required .eb.EdgeBlendSettings bottom_edge_settings = 6;
inline bool Workspace::has_bottom_edge_settings() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Workspace::set_has_bottom_edge_settings() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Workspace::clear_has_bottom_edge_settings() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Workspace::clear_bottom_edge_settings() {
  if (bottom_edge_settings_ != NULL) bottom_edge_settings_->::eb::EdgeBlendSettings::Clear();
  clear_has_bottom_edge_settings();
}
inline const ::eb::EdgeBlendSettings& Workspace::bottom_edge_settings() const {
  return bottom_edge_settings_ != NULL ? *bottom_edge_settings_ : *default_instance_->bottom_edge_settings_;
}
inline ::eb::EdgeBlendSettings* Workspace::mutable_bottom_edge_settings() {
  set_has_bottom_edge_settings();
  if (bottom_edge_settings_ == NULL) bottom_edge_settings_ = new ::eb::EdgeBlendSettings;
  return bottom_edge_settings_;
}
inline ::eb::EdgeBlendSettings* Workspace::release_bottom_edge_settings() {
  clear_has_bottom_edge_settings();
  ::eb::EdgeBlendSettings* temp = bottom_edge_settings_;
  bottom_edge_settings_ = NULL;
  return temp;
}
inline void Workspace::set_allocated_bottom_edge_settings(::eb::EdgeBlendSettings* bottom_edge_settings) {
  delete bottom_edge_settings_;
  bottom_edge_settings_ = bottom_edge_settings;
  if (bottom_edge_settings) {
    set_has_bottom_edge_settings();
  } else {
    clear_has_bottom_edge_settings();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace eb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eb::EditMode>() {
  return ::eb::EditMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eb::DisplayMode>() {
  return ::eb::DisplayMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eb::SelectMode>() {
  return ::eb::SelectMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eb::ControlPointType>() {
  return ::eb::ControlPointType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_eb_2eproto__INCLUDED
